package net.powermatcher.remote.websockets.client;

import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.Map;
import java.util.concurrent.Future;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

import org.eclipse.jetty.util.ssl.SslContextFactory;
import org.eclipse.jetty.websocket.api.CloseStatus;
import org.eclipse.jetty.websocket.api.Session;
import org.eclipse.jetty.websocket.api.WebSocketException;
import org.eclipse.jetty.websocket.api.annotations.OnWebSocketClose;
import org.eclipse.jetty.websocket.api.annotations.OnWebSocketMessage;
import org.eclipse.jetty.websocket.api.annotations.WebSocket;
import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;
import org.eclipse.jetty.websocket.client.WebSocketClient;
import org.osgi.framework.BundleContext;
import org.osgi.framework.ServiceRegistration;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.gson.JsonSyntaxException;

import aQute.bnd.annotation.component.Activate;
import aQute.bnd.annotation.component.Component;
import aQute.bnd.annotation.component.Deactivate;
import aQute.bnd.annotation.metatype.Configurable;
import aQute.bnd.annotation.metatype.Meta;
import net.powermatcher.api.MatcherEndpoint;
import net.powermatcher.api.messages.BidUpdate;
import net.powermatcher.api.messages.PriceUpdate;
import net.powermatcher.api.monitoring.ObservableAgent;
import net.powermatcher.core.BaseMatcherEndpoint;
import net.powermatcher.core.bidcache.AggregatedBid;
import net.powermatcher.core.concentrator.BidHistoryStore;
import net.powermatcher.core.concentrator.SentBidInformation;
import net.powermatcher.remote.websockets.data.ClusterInfoModel;
import net.powermatcher.remote.websockets.data.PmMessage;
import net.powermatcher.remote.websockets.data.PmMessage.PayloadType;
import net.powermatcher.remote.websockets.data.PriceUpdateModel;
import net.powermatcher.remote.websockets.json.ModelMapper;
import net.powermatcher.remote.websockets.json.PmJsonSerializer;

/**
 * WebSocket implementation of an {@link MatcherEndpoint}. Enabled two agents to communicate via WebSockets and JSON
 * over a TCP connection.
 *
 * @author FAN
 * @version 2.1
 */
@WebSocket()
@Component(designateFactory = WebsocketClient.Config.class,
           immediate = true,
           provide = { ObservableAgent.class })
public class WebsocketClient
    extends BaseMatcherEndpoint {

    private static final Logger LOGGER = LoggerFactory.getLogger(WebsocketClient.class);

    @Meta.OCD(description = "Remote client over websockets configuration")
    public static interface Config {
        @Meta.AD(deflt = "matcherendpointproxy", description = "The unique identifier of the agent")
        String agentId();

        @Meta.AD(deflt = "connection5", description = "The uniq identifier of the connection (e.g. username)")
        String connectionId();

        @Meta.AD(deflt = "ws://192.168.0.152:8080/powermatcher/websocket",
                 description = "URL daw")
        String powermatcherUrl();

        @Meta.AD(deflt = "30", description = "reconnect timeout keeping the connection alive.")
        int reconnectTimeout();

        @Meta.AD(deflt = "60", description = "connect timeout to wait for remote server to respond.")
        int connectTimeout();

        @Meta.AD(deflt = "1000",
                 description = "Mimimum time between two BidUpdates generated by the Concentratro in milliseconds")
        long minTimeBetweenBidUpdates();
    }

    private URI powermatcherUrl;

    private Session remoteSession;

    private WebSocketClient client;

    private int reconnectDelay, connectTimeout;

    private long minTimeBetweenBidUpdates;

    private BundleContext bundleContext;

    private ServiceRegistration<MatcherEndpoint> matcherEndpointServiceRegistration;

    private final ScheduledThreadPoolExecutor executorService = new ScheduledThreadPoolExecutor(1);

    private ScheduledFuture<?> scheduledFuture;

    private final AtomicInteger bidNumberGenerator = new AtomicInteger();

    private final BidHistoryStore sentBids = new BidHistoryStore();

    /**
     * OSGi calls this method to activate a managed service.
     *
     * @param properties
     *            the configuration properties
     * @throws Exception
     */
    @Activate
    public void activate(BundleContext bundleContext, Map<String, Object> properties) throws Exception {
        // Read configuration properties
        Config config = Configurable.createConfigurable(Config.class, properties);
        init(config.agentId());

        try {
            powermatcherUrl = new URI(config.powermatcherUrl() + "?agentId="
                                      + getAgentId()
                                      + "&connectionId="
                                      + config.connectionId());
        } catch (URISyntaxException e) {
            LOGGER.error("Malformed URL for powermatcher websocket endpoint. Reason {}", e);
            return;
        }

        reconnectDelay = config.reconnectTimeout();
        connectTimeout = config.connectTimeout();
        minTimeBetweenBidUpdates = config.minTimeBetweenBidUpdates();

        this.bundleContext = bundleContext;

        SslContextFactory ssl = new SslContextFactory();
        client = new WebSocketClient(ssl);
        try {
            client.start();
        } catch (Exception e) {
            LOGGER.warn("Could not start websocket client: " + e.getMessage(), e);
            throw e;
        }

        Runnable reconnectJob = new Runnable() {
            @Override
            public void run() {
                connectRemote();
            }
        };
        scheduledFuture = executorService.scheduleAtFixedRate(reconnectJob,
                                                              1,
                                                              reconnectDelay,
                                                              TimeUnit.SECONDS);
    }

    /**
     * OSGi calls this method to deactivate a managed service.
     */
    @Deactivate
    public void deactivate() {
        try {
            client.stop();
        } catch (Exception e) {
            LOGGER.warn("Could not stop websocket client: " + e.getMessage(), e);
        }
        unregisterMatcherEndpoint();
        scheduledFuture.cancel(true);
        disconnectRemote();
    }

    /**
     * {@inheritDoc}
     *
     * This specific implementation opens a websocket.
     */
    private void connectRemote() {
        if (!isRemoteConnected()) {
            // Try to setup a new websocket connection.
            try {
                ClientUpgradeRequest request = new ClientUpgradeRequest();
                Future<Session> connectFuture = client.connect(this, powermatcherUrl, request);
                LOGGER.info("Connecting to : {}", request.getRequestURI());

                // Wait configurable time for remote to respond
                remoteSession = connectFuture.get(connectTimeout, TimeUnit.SECONDS);
            } catch (Exception e) {
                LOGGER.error("Unable to connect to remote agent. Reason {}", e);
                remoteSession = null;
            }
        }
    }

    /**
     * {@inheritDoc}
     *
     * This specific implementation closes the open websocket.
     */
    private void disconnectRemote() {
        // Terminate remote session (if any)
        if (isRemoteConnected()) {
            remoteSession.close(new CloseStatus(0, "Normal disconnect"));
        }
    }

    /**
     * Determines whether the Websocket is connected.
     *
     * @return true when connected, false otherwise
     */
    public boolean isRemoteConnected() {
        return remoteSession != null && remoteSession.isOpen();
    }

    /**
     *
     * @param statusCode
     * @param reason
     */
    @OnWebSocketClose
    public void onDisconnect(int statusCode, String reason) {
        LOGGER.info("Connection closed: {} - {}", statusCode, reason);
        remoteSession = null;
        unconfigure();
        unregisterMatcherEndpoint();
    }

    /**
     * Handle Websocket receive message
     *
     * @param message
     *            the message received via Websockets
     */
    @OnWebSocketMessage
    public void onMessage(String message) {
        LOGGER.debug("Received message from remote agent {}", message);

        try {
            // Decode the JSON data
            PmJsonSerializer serializer = new PmJsonSerializer();
            PmMessage pmMessage = serializer.deserialize(message);

            if (!getStatus().isConnected()) {
                if (pmMessage.getPayloadType() == PayloadType.CLUSTERINFO) {
                    // Sync marketbasis and clusterid with local session, for new
                    // connections
                    ClusterInfoModel clusterInfo = (ClusterInfoModel) pmMessage.getPayload();
                    configure(ModelMapper.convertMarketBasis(clusterInfo.getMarketBasis()),
                              clusterInfo.getClusterId(),
                              minTimeBetweenBidUpdates);

                    // Register the MatcherEndpoint with the OSGI runtime, to make it available for connections
                    registerMatcherEndpoint();
                } else {
                    LOGGER.warn("Got unexpected message type [{}], expected CLUSTERINFO", pmMessage.getPayloadType());
                }
            } else {
                // Handle specific message
                if (pmMessage.getPayloadType() == PayloadType.PRICE_UPDATE) {
                    // Relay price update to local agents
                    PriceUpdate priceUpdate = ModelMapper.mapPriceUpdate((PriceUpdateModel) pmMessage.getPayload());

                    SentBidInformation info = sentBids.retrieveAggregatedBid(priceUpdate.getBidNumber());
                    publishPrice(priceUpdate.getPrice(), info.getOriginalBid());
                } else {
                    LOGGER.warn("Got unexpected message type [{}], expected PRICE_UPDATE", pmMessage.getPayloadType());
                }
            }
        } catch (JsonSyntaxException e) {
            LOGGER.warn("Unable to understand message from remote agent: {}", message);
        }
    }

    /**
     * {@inheritDoc}
     *
     */
    @Override
    protected void performUpdate(AggregatedBid aggregatedBid) {
        synchronized (sentBids) {
            BidUpdate bidUpdate = publishBid(aggregatedBid);
            if (bidUpdate != null) {
                sentBids.saveBid(aggregatedBid, bidUpdate);
            }
        }
    }

    /**
     * Publish an AggregatedBid via Websockets to {@link AgentProxy}
     *
     * @param newBid
     *            the bid to publish
     * @return bidupdate containing bidnumber and published bid
     *
     */
    private BidUpdate publishBid(AggregatedBid newBid) {

        LOGGER.debug("Please show up.");

        BidUpdate update = new BidUpdate(newBid, bidNumberGenerator.incrementAndGet());
        PmJsonSerializer serializer = new PmJsonSerializer();
        String message = serializer.serializeBidUpdate(update);
        LOGGER.debug("Please show up1.");

        /*
         * InetAddress IPhl; try { IPhl = InetAddress.getLocalHost(); data.bsourceIP(IPhl.getHostAddress()); // IP of
         * the localhost } catch (UnknownHostException e1) { // TODO Auto-generated catch block e1.printStackTrace(); }
         */
        LOGGER.info("Magpakita ka pls");
        /*
         * Sending data to the blockchain
         */

        if (isRemoteConnected()) {
            try {
                remoteSession.getRemote().sendString(message);
                LOGGER.debug("Napadala ang bid update to server {}", update);
                return update;
            } catch (IOException | WebSocketException | NullPointerException e) {
                LOGGER.error("Unable to send new bid to remote agent. Reason {}", e);
                return null;
            }
        } else {
            LOGGER.info("Can not send new bid, not connected (remote.isOpen={})",
                        remoteSession == null ? false : remoteSession.isOpen());
            return null;
        }

        /*
         * ApiClient client = new ApiClient(); client.setBasePath("http://192.168.0.100:3000/");
         * client.setConnectTimeout(60000); client.setDebugging(true); HlBidApi HlApi = new HlBidApi(); HLBid data = new
         * HLBid(); // Bid | Model instance data data.hlBidNumber(Integer.toString(update.getBidNumber())); // bidnumber
         * for BC double[] BidValue = newBid.getDemand(); ArrayList<Double> BidValueList = new ArrayList<Double>(); for
         * (double d : BidValue) { BidValueList.add(d); } InetAddress IPhl; try { IPhl = InetAddress.getLocalHost();
         * data.bsourceIP(IPhl.getHostAddress()); // IP of the localhost } catch (UnknownHostException e1) { // TODO
         * Auto-generated catch block e1.printStackTrace(); } try { HLBid result = HlApi.hLBidCreate(data);
         * LOGGER.debug("gg boys{}", result); } catch (ApiException e) {
         * LOGGER.error("Exception when calling BidApi#bidCreate {}", e); }
         */
    }

    /**
     * Send data to the BlockChain
     */

    /**
     * Register the MatcherEndpoint service
     */
    private void registerMatcherEndpoint() {
        if (matcherEndpointServiceRegistration == null) {
            matcherEndpointServiceRegistration = bundleContext.registerService(MatcherEndpoint.class, this, null);
        }
    }

    /**
     * Unregister the MatcherEndpoint service
     */
    private void unregisterMatcherEndpoint() {
        if (matcherEndpointServiceRegistration != null) {
            matcherEndpointServiceRegistration.unregister();
            matcherEndpointServiceRegistration = null;
        }
    }
}

/*
 * package io.swagger.example;
 *
 * import io.swagger.client.*; import io.swagger.client.auth.*; import io.swagger.client.model.*; import
 * io.swagger.client.api.BidApi;
 *
 * import java.io.File; import java.util.*;
 *
 * public class BidApiExample {
 *
 * public static void main(String[] args) {
 *
 * BidApi apiInstance = new BidApi();
 *
 * String BidClass = "org.powermatcher.Bid"; String BidIP = "192.168.0.22"; String BidNumber = "22";
 *
 * double[] BidValue = {30,40.55,55.55,99.99}; ArrayList<Double> BidValueList = new ArrayList<Double>(); for(double d :
 * BidValue) BidValueList.add(d);
 *
 * Bid data = new Bid(); // Bid | Model instance data data.bsourceIP("192.168.0.99"); data.bidNumber("11");
 * data.value(BidValueList); try { Bid result = apiInstance.bidCreate(data); System.out.println(result); } catch
 * (ApiException e) { System.err.println("Exception when calling BidApi#bidCreate"); e.printStackTrace(); } } }
 */
